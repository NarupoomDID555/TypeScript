=== tests/cases/conformance/dynamicImport/importCallExpressionShouldNotGetParen.ts ===
const localeName = "zh-CN";
>localeName : "zh-CN"
>"zh-CN" : "zh-CN"

import(`./locales/${localeName}.js`).then(bar => {
>import(`./locales/${localeName}.js`).then(bar => {    let x = bar;}) : Promise<void>
>import(`./locales/${localeName}.js`).then : <TResult1 = any, TResult2 = never>(onfulfilled?: (value: any) => TResult1, onrejected?: (reason: any) => TResult2) => Promise<(TResult1 extends undefined ? TResult1 : TResult1 extends PromiseLike<infer UResult1> ? UResult1 : TResult1) | (TResult2 extends undefined ? TResult2 : TResult2 extends PromiseLike<infer UResult2> ? UResult2 : TResult2)>
>import(`./locales/${localeName}.js`) : Promise<any>
>`./locales/${localeName}.js` : string
>localeName : "zh-CN"
>then : <TResult1 = any, TResult2 = never>(onfulfilled?: (value: any) => TResult1, onrejected?: (reason: any) => TResult2) => Promise<(TResult1 extends undefined ? TResult1 : TResult1 extends PromiseLike<infer UResult1> ? UResult1 : TResult1) | (TResult2 extends undefined ? TResult2 : TResult2 extends PromiseLike<infer UResult2> ? UResult2 : TResult2)>
>bar => {    let x = bar;} : (bar: any) => void
>bar : any

    let x = bar;
>x : any
>bar : any

});

import("./locales/" + localeName + ".js").then(bar => {
>import("./locales/" + localeName + ".js").then(bar => {    let x = bar;}) : Promise<void>
>import("./locales/" + localeName + ".js").then : <TResult1 = any, TResult2 = never>(onfulfilled?: (value: any) => TResult1, onrejected?: (reason: any) => TResult2) => Promise<(TResult1 extends undefined ? TResult1 : TResult1 extends PromiseLike<infer UResult1> ? UResult1 : TResult1) | (TResult2 extends undefined ? TResult2 : TResult2 extends PromiseLike<infer UResult2> ? UResult2 : TResult2)>
>import("./locales/" + localeName + ".js") : Promise<any>
>"./locales/" + localeName + ".js" : string
>"./locales/" + localeName : string
>"./locales/" : "./locales/"
>localeName : "zh-CN"
>".js" : ".js"
>then : <TResult1 = any, TResult2 = never>(onfulfilled?: (value: any) => TResult1, onrejected?: (reason: any) => TResult2) => Promise<(TResult1 extends undefined ? TResult1 : TResult1 extends PromiseLike<infer UResult1> ? UResult1 : TResult1) | (TResult2 extends undefined ? TResult2 : TResult2 extends PromiseLike<infer UResult2> ? UResult2 : TResult2)>
>bar => {    let x = bar;} : (bar: any) => void
>bar : any

    let x = bar;
>x : any
>bar : any

});
