=== tests/cases/compiler/correctOrderOfPromiseMethod.ts ===
interface A {
    id: string
>id : string
}

interface B {
    id: string
>id : string

    fieldB: string
>fieldB : string
}

async function countEverything(): Promise<number> {
>countEverything : () => Promise<number>

    const providerA = async (): Promise<A[]> => { return [] }
>providerA : () => Promise<A[]>
>async (): Promise<A[]> => { return [] } : () => Promise<A[]>
>[] : undefined[]

    const providerB = async (): Promise<B[]> => { return [] }
>providerB : () => Promise<B[]>
>async (): Promise<B[]> => { return [] } : () => Promise<B[]>
>[] : undefined[]

    const [resultA, resultB] = await Promise.all([
>resultA : A[]
>resultB : B[]
>await Promise.all([        providerA(),        providerB(),    ] as const) : [A[], B[]]
>Promise.all([        providerA(),        providerB(),    ] as const) : Promise<[A[], B[]]>
>Promise.all : { <TAll>(values: Iterable<TAll>): Promise<(TAll extends undefined ? TAll : TAll extends PromiseLike<infer UAll> ? UAll : TAll)[]>; <T extends readonly any[]>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]>; }>; }
>Promise : PromiseConstructor
>all : { <TAll>(values: Iterable<TAll>): Promise<(TAll extends undefined ? TAll : TAll extends PromiseLike<infer UAll> ? UAll : TAll)[]>; <T extends readonly any[]>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]>; }>; }
>[        providerA(),        providerB(),    ] as const : readonly [Promise<A[]>, Promise<B[]>]
>[        providerA(),        providerB(),    ] : readonly [Promise<A[]>, Promise<B[]>]

        providerA(),
>providerA() : Promise<A[]>
>providerA : () => Promise<A[]>

        providerB(),
>providerB() : Promise<B[]>
>providerB : () => Promise<B[]>

    ] as const);

    const dataA: A[] = resultA;
>dataA : A[]
>resultA : A[]

    const dataB: B[] = resultB;
>dataB : B[]
>resultB : B[]

    if (dataA && dataB) {
>dataA && dataB : B[]
>dataA : A[]
>dataB : B[]

        return dataA.length + dataB.length;
>dataA.length + dataB.length : number
>dataA.length : number
>dataA : A[]
>length : number
>dataB.length : number
>dataB : B[]
>length : number
    }
    return 0;
>0 : 0
}

